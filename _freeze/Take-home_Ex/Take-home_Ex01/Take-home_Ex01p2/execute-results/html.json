{
  "hash": "2991658a797cf1d2d52d8bd7e5c838b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 1: Phase 2\"\nauthor: \"Nor Hendra\"\ndate: \"30 April 2025\"\ndate-modified: \"last-modified\"\nformat: html\ncode-fold: true\ncode-summary: \"Show code\"\neditor: visual\nfreeze: true\nexecute:\n  eval: true\n  echo: true\n  warning: false\n---\n\n```{=html}\n<style>\np {\n  text-align: justify;\n}\nbody, \nbody p, \nbody h1, \nbody h2, \nbody h3, \nbody h4, \nbody h5, \nbody h6, \nbody li {\n  color: #000 !important;\n}\n</style>\n```\n\n\n\n# 1. Overview\n\nIn Phase 1 of Take-home Exercise 1, we were tasked to prepare and design data visualisation for the article. The data we used was the *Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024* available on [Singstat](https://www.singstat.gov.sg/). In this phase 2, I will be selecting a fellow classmate to critic three good design principles and three areas for further improvement.\n\n::: callout-important\n## PURPOSE\n\n**I hope the audience is able to appreciate how I have provided the step by step code to see how the plot evolves and why I made each change. My goal is to take you through my thought process for every improvement and show how each tweak builds towards the polished final visualization without changing too much of the main skeleton of the original author's code.**\n:::\n\n# 2. Getting started\n\nI have chosen to use [this classmate's plot](https://iss608-vaa.netlify.app/take-home_ex/take-home_ex01/take%20home%20exercise%201) of the Population Pyramid. Before we get started on analyzing his pyramid. Let's load the data and packages required for this!\n\n## 2.1 Importing Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, readxl, ggplot2, ggthemes, dplyr, scales,forcats, ggplot)\n```\n:::\n\n\n\n## 2.2 Data Loading and Cleaning for Plotting\n\nI will be doing the same steps I did in phase 1 to clean the data before proceeding. [Skip ahead](#maintask) to get to the main task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsgdemo2024 <- read_csv((\"data/respopagesex2024.csv\"), show_col_types = FALSE)\n```\n:::\n\n\n\n### 2.2.1 Converting Sex to a factor with the correct order\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    Sex = factor(Sex, levels = c(\"Males\", \"Females\"))\n  )\n```\n:::\n\n\n\n### 2.2.2 Count missing values by column\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Check for missing values and confirm none\nmissing_counts <- sgdemo2024 %>% \n  summarise_all(~ sum(is.na(.)))\n\nif (all(unlist(missing_counts) == 0)) {\n  cat(\"✅ No missing values, proceed to the next check\\n\")\n} else {\n  warning(\"⚠️ Missing values detected:\")\n  print(missing_counts)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ No missing values, proceed to the next check\n```\n\n\n:::\n:::\n\n\n\n### 2.2.3 Checking for any duplicates\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndup_count <- sum(duplicated(sgdemo2024))\n\nif (dup_count == 0) {\n  cat(\"✅ No duplicates, on to the next!\\n\")\n} else {\n  warning(\"⚠️ Found duplicate rows:\")\n  print(sgdemo2024[duplicated(sgdemo2024), ])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ No duplicates, on to the next!\n```\n\n\n:::\n:::\n\n\n\n### 2.2.4 Ensure population is strictly positive\n\n**Step 1: Checking for zero-population rows.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Check for zero-population rows\nzero_rows <- sgdemo2024 %>% \n  filter(Pop == 0)\n\nif (nrow(zero_rows) > 0) {\n  cat(\"⚠️ Found\", nrow(zero_rows), \"rows with Pop == 0 (empty demographic cells):\\n\")\n  print(head(zero_rows))    # show a few examples\n} else {\n  cat(\"✅ No zero‐population rows found.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n⚠️ Found 23181 rows with Pop == 0 (empty demographic cells):\n# A tibble: 6 × 6\n  PA         SZ                     Age   Sex       Pop  Time\n  <chr>      <chr>                  <chr> <fct>   <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 80    Males       0  2024\n2 Ang Mo Kio Ang Mo Kio Town Centre 86    Males       0  2024\n3 Ang Mo Kio Ang Mo Kio Town Centre 86    Females     0  2024\n4 Ang Mo Kio Ang Mo Kio Town Centre 88    Males       0  2024\n5 Ang Mo Kio Ang Mo Kio Town Centre 89    Males       0  2024\n6 Ang Mo Kio Ang Mo Kio Town Centre 89    Females     0  2024\n```\n\n\n:::\n:::\n\n\n\n**Step 2: Removing those zero-population rows.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Remove all zero‐population rows\nsgdemo2024 <- sgdemo2024 %>% \n  filter(Pop > 0)\n```\n:::\n\n\n\n**Step 3: Confirm that all rows with zero-population has been removed.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Confirm removal\nif (sum(sgdemo2024$Pop == 0) == 0) {\n  cat(\"✅ All zero‐population rows removed. Data is now focused on actual residents.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ All zero‐population rows removed. Data is now focused on actual residents.\n```\n\n\n:::\n:::\n\n\n\n### 2.2.5 Check Age Range & Filter to Plausible Values\n\n**Step 1: Convert the '90 & Over' to integers.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Inspect column names to confirm they match expectations\nprint(colnames(sgdemo2024))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PA\"   \"SZ\"   \"Age\"  \"Sex\"  \"Pop\"  \"Time\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Convert \"Age\" → numeric, mapping \"90 & Over\" → 90\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    Age = parse_number(as.character(Age)),  \n    Age = as.integer(Age)                   \n  )\n\n# 3. Verify the transformation\nage_stats <- sgdemo2024 %>%\n  summarise(\n    min_age = min(Age, na.rm = TRUE),\n    max_age = max(Age, na.rm = TRUE)\n  )\n\ncat(sprintf(\n  \"✅ Age conversion complete: now an integer from %d to %d.\\n\",\n  age_stats$min_age, age_stats$max_age\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ Age conversion complete: now an integer from 0 to 90.\n```\n\n\n:::\n:::\n\n\n\n**Step 2: Confirm that there are no more \"90 & Over\" entries in my data.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(sgdemo2024$Age == \"90 & Over\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n**Step 3: Confirm the column type for Age is integer.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"Age column type:\", class(sgdemo2024$Age), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAge column type: integer \n```\n\n\n:::\n:::\n\n\n\n**Step 4: Ensure no NA in the column for Age.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nna_count <- sum(is.na(sgdemo2024$Age))\ncat(\"Number of NA in Age after parsing:\", na_count, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of NA in Age after parsing: 0 \n```\n\n\n:::\n:::\n\n\n\n### 2.2.6 Confirm Sex Factor Levels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Count subzone‐level totals (SZ == \"Total\")\nn_sz_total <- sum(sgdemo2024$SZ == \"Total\", na.rm = TRUE)\ncat(\"Rows with SZ == \\\"Total\\\":\", n_sz_total, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with SZ == \"Total\": 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Count any Age == NA (originally \"Total\")\nn_age_na <- sum(is.na(sgdemo2024$Age))\ncat(\"Rows with Age == NA (was \\\"Total\\\"):\", n_age_na, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with Age == NA (was \"Total\"): 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 3. Count any Sex == \"Total\"\nn_sex_total <- sum(as.character(sgdemo2024$Sex) == \"Total\", na.rm = TRUE)\ncat(\"Rows with Sex == \\\"Total\\\":\", n_sex_total, \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with Sex == \"Total\": 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 4. If any totals remain, peek at them\nif (n_sz_total + n_age_na + n_sex_total > 0) {\n  cat(\"⚠️ Example summary‐row(s):\\n\")\n  sgdemo2024 %>%\n    filter(\n      SZ == \"Total\" |\n      is.na(Age)    |\n      as.character(Sex) == \"Total\"\n    ) %>%\n    slice_head(n = 5) %>%\n    print()\n} else {\n  cat(\"✅ No summary‐row entries remain. You’re all set.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ No summary‐row entries remain. You’re all set.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the expected order\nexpected_levels <- c(\"Males\", \"Females\")\n\n# Inspect the current factor levels\nactual_levels <- levels(sgdemo2024$Sex)\ncat(\"Current Sex levels:\", paste(actual_levels, collapse = \", \"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCurrent Sex levels: Males, Females \n```\n\n\n:::\n\n```{.r .cell-code}\n# Compare and act\nif (identical(actual_levels, expected_levels)) {\n  cat(\"✅ Sex factor levels are already correct (Males, Females).\\n\")\n} else {\n  warning(\"⚠️ Sex factor levels are not as expected. Resetting to Males, Females.\")\n  sgdemo2024 <- sgdemo2024 %>%\n    mutate(Sex = factor(Sex, levels = expected_levels))\n  cat(\"✅ Sex factor levels have been reset to:\", \n      paste(levels(sgdemo2024$Sex), collapse = \", \"), \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ Sex factor levels are already correct (Males, Females).\n```\n\n\n:::\n:::\n\n\n\n### 2.2.7 Checking for any 'Total' in Columns and Final Checks\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Count subzone‐level totals (SZ == \"Total\")\nn_sz_total <- sum(sgdemo2024$SZ == \"Total\", na.rm = TRUE)\ncat(\"Rows with SZ == \\\"Total\\\":\", n_sz_total, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with SZ == \"Total\": 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Count any Age == NA (originally \"Total\")\nn_age_na <- sum(is.na(sgdemo2024$Age))\ncat(\"Rows with Age == NA (was \\\"Total\\\"):\", n_age_na, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with Age == NA (was \"Total\"): 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 3. Count any Sex == \"Total\"\nn_sex_total <- sum(as.character(sgdemo2024$Sex) == \"Total\", na.rm = TRUE)\ncat(\"Rows with Sex == \\\"Total\\\":\", n_sex_total, \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows with Sex == \"Total\": 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 4. If any totals remain, peek at them\nif (n_sz_total + n_age_na + n_sex_total > 0) {\n  cat(\"⚠️ Example summary‐row(s):\\n\")\n  sgdemo2024 %>%\n    filter(\n      SZ == \"Total\" |\n      is.na(Age)    |\n      as.character(Sex) == \"Total\"\n    ) %>%\n    slice_head(n = 5) %>%\n    print()\n} else {\n  cat(\"✅ No summary‐row entries remain. You’re all set.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ No summary‐row entries remain. You’re all set.\n```\n\n\n:::\n:::\n\n\n\n# 3. Reworking the Pyramid Plot {#maintask}\n\n## 3.1 Population Pyramid\n\n::: callout-important\n## Rewriting code\n\nI had to rewrite the earlier stages of the code before plotting the pyramid as I have cleaned and renamed my data. Below is a comparison from a screenshot of the plot and the plot I created based off [his](https://iss608-vaa.netlify.app/take-home_ex/take-home_ex01/take%20home%20exercise%201) code. Although there are slight differences in code, the overall aesthetic and function of the plot remains the same.\n:::\n\n::: panel-tabset\n## Classmate's Plot\n\n\n\n```{=html}\n<img src=\"EnricoPlot.png\" alt=\"Alt text for accessibility\"\n     style=\"display:block; margin:0 auto; width:90%;\" />\n```\n\n\n\n## Classmate's Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npyramid_data <- aggregate(Pop ~ `AG` + Sex, data = Resident_Data, sum)\n\nage_order <- c(\"0_to_4\", \"5_to_9\", \"10_to_14\", \"15_to_19\", \"20_to_24\", \"25_to_29\", \n               \"30_to_34\", \"35_to_39\", \"40_to_44\", \"45_to_49\", \"50_to_54\", \"55_to_59\", \n               \"60_to_64\", \"65_to_69\", \"70_to_74\", \"75_to_79\", \"80_to_84\", \"85_to_89\", \n               \"90_and_over\")\n\npyramid_data$AG <- factor(pyramid_data$AG, levels = age_order)\n\npyramid_data$Pop[pyramid_data$Sex == \"Males\"] <- -pyramid_data$Pop[pyramid_data$Sex == \"Males\"]\n\nggplot(data = pyramid_data, aes(x = AG, y = Pop, fill = Sex)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  labs(title = \"Population Pyramid (2024)\", x = \"Age Group\", y = \"Population\") +\n  scale_y_continuous(labels = comma) +\n  scale_fill_manual(values = c(\"skyblue\", \"salmon\")) + \n  theme_minimal() +\n  theme(axis.text.y = element_text(size = 10))  \n```\n:::\n\n\n\n## Duplicated Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n## The Code (Alternate Version)\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsgdemo2024 <- sgdemo2024 %>% \n  mutate(Age = as.numeric(as.character(Age)))\n\nage_order <- c(\n  \"0_to_4\", \"5_to_9\",  \"10_to_14\", \"15_to_19\", \"20_to_24\", \"25_to_29\",\n  \"30_to_34\",\"35_to_39\",\"40_to_44\", \"45_to_49\", \"50_to_54\", \"55_to_59\",\n  \"60_to_64\",\"65_to_69\",\"70_to_74\", \"75_to_79\", \"80_to_84\", \"85_to_89\",\n  \"90_and_over\"\n)\n\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    AG = cut(\n      Age,\n      breaks = c(seq(0, 90, by = 5), Inf),\n      right  = FALSE,\n      labels = age_order\n    ),\n    AG = fct_explicit_na(AG, na_level = \"90_and_over\")\n  )\n\npyramid_data <- sgdemo2024 %>%\n  group_by(AG, Sex) %>%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %>%\n  mutate(Pop = if_else(Sex == \"Males\", -Pop, Pop))\n\nggplot(pyramid_data, aes(x = AG, y = Pop, fill = Sex)) +\n  geom_col(width = 0.8) +\n  coord_flip() +\n  scale_y_continuous(labels = comma) +\n  scale_fill_manual(\n    values = c(\n      Males   = \"salmon\",\n      Females = \"skyblue\"\n    )\n  ) +\n  labs(\n    title = \"Population Pyramid (2024)\",\n    x     = \"Age Group\",\n    y     = \"Population\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.y        = element_text(size = 10)\n  )\n```\n:::\n\n\n:::\n\n## 3.2 Three Good Design Principles\n\n1.  **Symmetric, Diverging Bars for Easy Comparison**\n\n    By plotting males on the left and females on the right, with a shared zero-center. I am able to instantly compare cohort sizes across the aisle. The mirror layout makes it easy to see at a glance which age groups are male or female dominated and by roughly how much.\n\n2.  **Ordered, Evenly-Spaced Age Bands**\n\n    The age groups run in a logical 5 year increment from bottom to top and they remain evenly spaced and sorted. This consistent ordering prevents cognitive load where viewers don't have to hunt for a specific age group, for example the \"20 to 24\" in the middle of the chart. This also helps make trends (e.g. the bulge in middle ages) pop out immediately\n\n3.  **Clean and Minimalist Theme with Gridlines**\n\n    The light gridlines behind the bars gives you just enough reference to read values off the axis, without cluttering the visual.\n\n## 3.3 Areas of Improvement\n\n\n\n```{=html}\n<img src=\"4quadr.png\" alt=\"Alt text for accessibility\"\n     style=\"display:block; margin:0 auto; width:90%;\" />\n```\n\n\n\nAbove is the [four quadrants of clarity and aesthetic](https://dataremixed.com/2012/05/data-visualization-clarity-or-aesthetics/) and based on the good design principles I found outlined previously, I would put this in Quadrant IV - beautiful but confusing.\n\n\n\n```{=html}\n<img src=\"EnricoPlotEdited.png\" alt=\"Alt text for accessibility\"\n     style=\"display:block; margin:0 auto; width:90%;\" />\n```\n\n\n\nThe areas highlighted in red on the figure above are aspects I have some gripes with. The reason I said it is beautiful but confusing is because of the X-Axis and Y-Axis. The X-Axis indicating population shows value -100,000 to 100,000 - there is no such thing as a negative population (unless of course we are comparing those who aren't alive anymore). Furthermore, the Y-Axis (age bands) has underscores in between the age. This can be indeed a little off-putting on a plot Ideally, it should just be the age bands without any underscores in between.\n\n### 3.3.1 Improvement 1 - Fixing the Y-Axis\n\nLet's first work on renaming the age binning of the code to be without underscores. It would like something like below to replace the underscores.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Apply binning and label cleanup\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    AG = cut(Age, breaks = c(seq(0, 90, by = 5), Inf), right = FALSE, labels = age_order),\n    AG = fct_explicit_na(AG, na_level = \"90_and_over\"),\n    AG = gsub(\"_to_\", \"-\", AG),\n    AG = gsub(\"_and_over\", \"+\", AG),\n    AG = factor(AG, levels = gsub(\"_to_\", \"-\", gsub(\"_and_over\", \"+\", age_order)))\n  )\n```\n:::\n\n\n\n**Putting it Together - Plot after Improvement 1**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define age bins\nage_order <- c(\n  \"0 to 4\", \"5 to 9\",  \"10 to 14\", \"15 to 19\", \"20 to 24\", \"25 to 29\",\n  \"30 to 34\",\"35 to 39\",\"40 to 44\", \"45 to 49\", \"50 to 54\", \"55 to 59\",\n  \"60 to 64\",\"65 to 69\",\"70 to 74\", \"75 to 79\", \"80 to 84\", \"85 to 89\",\n  \"90+\"\n)\n\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    AG = cut(Age, breaks = c(seq(0, 90, by = 5), Inf), right = FALSE, labels = age_order),\n    AG = fct_explicit_na(AG, na_level = \"90_and_over\"),\n    AG = gsub(\"_to_\", \"-\", AG),\n    AG = gsub(\"_and_over\", \"+\", AG),\n    AG = factor(AG, levels = gsub(\"_to_\", \"-\", gsub(\"_and_over\", \"+\", age_order)))\n  )\n\npyramid_data <- sgdemo2024 %>%\n  group_by(AG, Sex) %>%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %>%\n  mutate(Pop = if_else(Sex == \"Males\", -Pop, Pop))\n\nggplot(pyramid_data, aes(x = AG, y = Pop, fill = Sex)) +\n  geom_col(width = 0.8) +\n  coord_flip() +\n  scale_y_continuous(labels = comma) +\n  scale_fill_manual(\n    values = c(\n      Males   = \"salmon\",\n      Females = \"skyblue\"\n    )\n  ) +\n  labs(\n    title = \"Population Pyramid (2024)\",\n    x     = \"Age Group\",\n    y     = \"Population\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.y        = element_text(size = 10)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n### 3.3.2 Improvement 2 - Fixing the X-Axis\n\nNext, let's fix the X-Axis by ensuring it is positive both ways and in 20,000 increments with below code. The top one would be to fix the negative population and the bottom to aggregate them to 20,000 incremental bins.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Aggregate and prepare data\npyramid_data <- sgdemo2024 %>%\n  group_by(AG, Sex) %>%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %>%\n  mutate(Pop = if_else(Sex == \"Males\", -Pop, Pop))\n\n# Determine max for 20k axis break\nmax_pop <- ceiling(max(abs(pyramid_data$Pop)) / 20000) * 20000\n```\n:::\n\n\n\nI will also ensure it limits the plot to just 180000 and stop there to prevent extra grids showing up using below code chunk\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nscale_y_continuous(\n  limits = c(-180000, 180000) / 1000,\n  breaks = seq(-180000, 180000, by = 20000) / 1000,\n  labels = function(x) abs(x),\n  expand = c(0, 0)\n)\n```\n:::\n\n\n\n**Putting it Together - Plot after Improvement 2**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define age bins\nage_order <- c(\n  \"0 to 4\", \"5 to 9\",  \"10 to 14\", \"15 to 19\", \"20 to 24\", \"25 to 29\",\n  \"30 to 34\",\"35 to 39\",\"40 to 44\", \"45 to 49\", \"50 to 54\", \"55 to 59\",\n  \"60 to 64\",\"65 to 69\",\"70 to 74\", \"75 to 79\", \"80 to 84\", \"85 to 89\",\n  \"90+\"\n)\n\n# Apply binning and label cleanup\nsgdemo2024 <- sgdemo2024 %>%\n  mutate(\n    AG = cut(Age, breaks = c(seq(0, 90, by = 5), Inf), right = FALSE, labels = age_order),\n    AG = fct_explicit_na(AG, na_level = \"90_and_over\"),\n    AG = gsub(\"_to_\", \"-\", AG),\n    AG = gsub(\"_and_over\", \"+\", AG),\n    AG = factor(AG, levels = gsub(\"_to_\", \"-\", gsub(\"_and_over\", \"+\", age_order)))\n  )\n\n# Aggregate and prepare data\npyramid_data <- sgdemo2024 %>%\n  group_by(AG, Sex) %>%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %>%\n  mutate(Pop = if_else(Sex == \"Males\", -Pop, Pop))\n\n# Determine max for 20k axis break\nmax_pop <- ceiling(max(abs(pyramid_data$Pop)) / 20000) * 20000\n\n# Force max_pop to show up to 180k at least\nmax_pop <- max(180000, ceiling(max(abs(pyramid_data$Pop)) / 20000) * 20000)\n\nggplot(pyramid_data, aes(x = AG, y = Pop / 1000, fill = Sex)) +  # Convert to thousands\n  geom_col(width = 0.8) +\n  coord_flip() +\nscale_y_continuous(\n  limits = c(-180000, 180000) / 1000,\n  breaks = seq(-180000, 180000, by = 20000) / 1000,\n  labels = function(x) abs(x),\n  expand = c(0, 0)\n)+\n  scale_fill_manual(values = c(Males = \"salmon\", Females = \"skyblue\")) +\n  labs(\n    title = \"Population Pyramid (2024)\",\n    x = \"Age Group\",\n    y = \"Population (in thousands)\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_text(size = 10),\n    panel.grid.major.y = element_line(color = \"gray90\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nGreat! Now it looks much better and cleaner than what it initially was. However, there are still some improvements to be made.\n\n### 3.3.3 Improvement 3 - Colour, Labels and Gridlines\n\n**Fixing Colour**: Another potential source of confusion lies in the color scheme chosen. The chart uses colors that invert the stereotypical associations—males are marked in \"salmon\" and females in \"skyblue\". When readers see that the chart relates to gender, they may instinctively rely on color cues rather than consult the legend, especially if those colors align with common assumptions. While the intention may have been to challenge gender norms, this reversal can unintentionally mislead viewers and hinder clarity. Personally, I would prefer to adjust the color palette entirely, but in order to preserve the integrity of the original design, I will simply switch the color assignments for clarity.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nscale_fill_manual(values = c(Males = \"skyblue\", Females = \"salmon\"))\n```\n:::\n\n\n\n**Adding percentage-of-population**: Absolute bar lengths show \"how many\" but not \"how large a share\" so I will be annotating each bar with its percentage to immediately tell the audience. This view will make both scale and structure transparent at a glance. Hence, even when 2 bars look of similar length, the percentage call-out removes any guessworrk readers have to mentally translate. Also, I'll be adding the total population in the header to immediately anchor every subsequent percentage to give more context to the percentages added. With below code chunk, I will be adjusting the header to calculate total population so that the percentages can be referenced, along with percentage of total population on each bar.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlabs(\n  title    = \"Population Pyramid (2024)\",               # ← your main header\n  subtitle = paste0(\"Total population: \", comma(total_pop)),\n                                                        # ← sub-header showing the formatted total\n  x        = \"Age Group\",\n  y        = \"Population (in thousands)\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  mutate(\n    Pop = if_else(Sex == \"Males\", -Pop, Pop),\n    pct = abs(Pop) / sum(abs(Pop)) * 100\n  )\n\ntotal_pop <- sum(abs(pct_data$Pop))\n```\n:::\n\n\n\n**Removing horizontal gridlines**: Since axis ticks and percentage labels already give precise reference points, the extra gridlines behind the bars no longer add new information and can even distract by creating \"railroad tracks\" that compete with the bars. Without horizontal gridlines, audience can still read each bar against the axis labels and allows for a cleaner backdrop that draws all attention to the data itself. Ultimately sharpening the demographic story without compromising clarity of precision.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntheme_minimal() +\ntheme(\n  panel.grid.major.y = element_blank(),                # ← removes the horizontal gridlines\n  panel.grid.major.x = element_line(color = \"gray90\", size = 0.3),\n  panel.grid.minor.x = element_line(color = \"gray90\", size = 0.3),\n  …\n)\n```\n:::\n\n\n\n## 3.4 Putting it Together - All Improvements (The Final Pyramid Plot)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage_order <- c(\n  \"0 to 4\", \"5 to 9\",  \"10 to 14\", \"15 to 19\", \"20 to 24\", \"25 to 29\",\n  \"30 to 34\",\"35 to 39\",\"40 to 44\", \"45 to 49\", \"50 to 54\", \"55 to 59\",\n  \"60 to 64\",\"65 to 69\",\"70 to 74\", \"75 to 79\", \"80 to 84\", \"85 to 89\",\n  \"90+\"\n)\n\npct_data <- sgdemo2024 %>%\n  mutate(\n    AG = cut(\n      Age,\n      breaks = c(seq(0, 90, by = 5), Inf),\n      right  = FALSE,\n      labels = age_order\n    ),\n    AG = fct_explicit_na(AG, na_level = \"90+\")\n  ) %>%\n  group_by(AG, Sex) %>%\n  summarise(Pop = sum(Pop), .groups = \"drop\") %>%\n  mutate(\n    Pop = if_else(Sex == \"Males\", -Pop, Pop),\n    pct = abs(Pop) / sum(abs(Pop)) * 100\n  )\n\ntotal_pop <- sum(abs(pct_data$Pop))\n\nggplot(pct_data, aes(x = AG, y = Pop/1000, fill = Sex)) +\n  geom_col(width = 0.8) +\n  geom_text(\n    aes(label = paste0(round(pct, 1), \"%\"),\n        hjust = if_else(Sex == \"Males\", 1.1, -0.1)\n    ),\n    size = 3, color = \"gray20\"\n  ) +\n  # clamp exactly at +/-180 and allow labels outside\n  scale_y_continuous(\n    limits = c(-180, 180),\n    breaks = seq(-180, 180, by = 20),\n    labels = abs,\n    expand = c(0, 0.02),    # small headroom so 180 isn't cut off\n    oob = scales::squish\n  ) +\n  coord_flip(clip = \"off\") +\n  scale_fill_manual(values = c(Males = \"skyblue\", Females = \"salmon\")) +\n  labs(\n    title    = \"Population Pyramid (2024)\",\n    subtitle = paste0(\"Total population: \", comma(total_pop)),\n    x        = \"Age Group\",\n    y        = \"Population (in thousands)\"\n  ) +\n  theme_minimal() +\n  theme(\n    # remove horizontal grid (behind bars), keep vertical grid for reference\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(color = \"gray90\", size=0.3),\n    panel.grid.minor.x = element_line(color = \"gray90\",size=0.3),\n\n    # move legend to right\n    legend.position    = \"right\",\n    legend.title       = element_blank(),\n    # center title + subtitle\n    plot.title         = element_text(hjust = 0.5, face= \"bold\"),\n    plot.subtitle      = element_text(hjust = 0.5)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-28-1.png){width=864}\n:::\n:::\n\n\n\n::: callout-important\n## **Conclusion**\n\nCompared to the original version, this revised pyramid is both cleaner and more informative. By placing each bar’s share of the total alongside its count, viewers can instantly gauge not just “how many” but “how big a slice” each age band represents. Centralizing the title and subtitle with the overall population right up front anchors the narrative, while bold axis labels reinforce the key dimensions. Removing non-essential horizontal gridlines sharpens focus on the data itself. Altogether, these tweaks make the demographic story more transparent, accessible, and visually engaging.\n:::\n\n# 4. Reworking the Bar Chart\n\nBelow is the bar chart plotted by the same [classmate](https://iss608-vaa.netlify.app/take-home_ex/take-home_ex01/take%20home%20exercise%201) and its code chunk. I just altered it for the data to use the data I have cleaned up.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Filter out any NA or zero rows\nfiltered_data <- sgdemo2024[!is.na(sgdemo2024$Pop) & sgdemo2024$Pop > 0, ]\n\n# 2. Draw the bar chart\nggplot(data = filtered_data, aes(x = reorder(PA, Pop), y = Pop)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +\n  labs(\n    title = \"Population by Planning Area (Singapore, 2024)\",\n    x     = \"Planning Area\",\n    y     = \"Population\"\n  ) +\n  scale_y_continuous(labels = comma) +\n  theme_minimal(base_size = 20) +\n  theme(\n    plot.title  = element_text(size = 18, face = \"bold\"),\n    axis.text.y = element_text(size = 15),\n    axis.text.x = element_text(size = 10),\n    plot.margin = margin(1, 1, 1, 1, \"cm\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-29-1.png){width=1152}\n:::\n:::\n\n\n\n## 4.1 Three Good Design Principles\n\n1.  **Horizontal bars**\n\n    I like that the plot is a horinzontal bar plot. This is because by flipping the axes so that the Planning Area names run along the y-axis means that I am able to see the full names (e.g \"Western Water Catchment\") legibly. If the plot had it on the x-axis, it would have been tiny, and rotated text.\n\n2.  **Minimalist Theme with Subtle Gridlines**\n\n    I like that the gridlights at the major tick marks are light grey as this removes all non-essential decorations. It allows the eye just enough reference to read off values without cluttering the canvas. It keeps the focus on the data itself.\n\n3.  **Practical Guides for Using Colour and Guides for Encoding Values in Graph**\n\n    In Lesson 2, we learned about practical guides of using colours in chart. I like how the plot has adhered to this rule but using the same colour and has not used different colors just for the sake of it. I also like how the values start at zero, which according to Lesson 2 - is a great thing! It ensures the bars shows a quantitative scale.\n\n## 4.2 Areas of Improvement\n\nAccording to the four quadrants of clarity and aesthetic and based on the grood design principles I outlined above, I would put this in Quadrant Above is the [four quadrants of clarity and aesthetic](https://dataremixed.com/2012/05/data-visualization-clarity-or-aesthetics/) and based on the good design principles I found outlined previously, I would put this in Quadrant II - clear but ugly.\n\n### 4.2.1 Improvement 1 - Descending Order\n\nThe bars are all over the place and not arranged in an orderly manner. It does not tell me any new information by putting it randomly - it is not as if the bars are arranged by regions and such. Hence, it is extremely confusing and looks all over the place. By fixing this and arranging them by magnitude, readers will be able to immediately see who's on top\" which tells the story at a glance. Furthermore, human perception excels at comparing nearby items of similar size. In a sorted bar chart, adjacent bars differ by the smallest possible increments, making it easy to judge differences.\n\nBelow code chunk will be added before the ggplot to arrange them in descending order from the top - from most populated to least populated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npa_totals <- sgdemo2024 %>%\n  group_by(PA) %>%\n  summarise(Pop = sum(Pop, na.rm = TRUE)) %>%\n  filter(Pop > 0) %>%            # drop zero/NA if you still want\n  arrange(desc(Pop))             # largest → smallest\npa_totals$PA <- factor(pa_totals$PA, levels = rev(pa_totals$PA))\n```\n:::\n\n\n\n**Putting it Together - Improvement 1**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Sum up Pop for each PA\npa_totals <- sgdemo2024 %>%\n  group_by(PA) %>%\n  summarise(Pop = sum(Pop, na.rm = TRUE)) %>%\n  filter(Pop > 0) %>%            # drop zero/NA if you still want\n  arrange(desc(Pop))             # largest → smallest\npa_totals$PA <- factor(pa_totals$PA, levels = rev(pa_totals$PA))\n\n# 3. Plot\nggplot(pa_totals, aes(x = PA, y = Pop)) +\n  geom_col(fill = \"steelblue\") +\n  coord_flip() +\n  scale_y_continuous(labels = comma) +\n  labs(\n    title = \"Population by Planning Area (Singapore, 2024)\",\n    x     = \"Planning Area\",\n    y     = \"Population\"\n  ) +\n  theme_minimal(base_size = 20) +\n  theme(\n    plot.title  = element_text(size = 18, face = \"bold\"),\n    axis.text.y = element_text(size = 15),\n    axis.text.x = element_text(size = 10),\n    plot.margin = margin(1, 1, 1, 1, \"cm\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-31-1.png){width=1152}\n:::\n:::\n\n\n\nDoesn't it already look better? We can instantly tell a story and use the natural human perception to gauge the population!\n\n### 4.2.2 Improvement 2 - Gridlines and Margins\n\nBecause the bars themselves run themselves run horizontally, adding grid lines in the same direction creates visual \"noise\" that doesn't add new information. Readers already naturally follow the length of each bar to compare values. By stripping out the horizontal grids, I can declutter the plot while still preserving the vertical grid lines that act as helpful reference ticks. WIth fewer lines means a higher \"data-ink ratio\" as we can guide the eye straight to the bars. Below code chunk will aim to achieve those things!\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# In the scale of your discrete (PA) axis, you allow just a tiny bit of padding:\nscale_x_discrete(expand = c(0, 0.02))\n\naxis.text.y = element_text(\n  size   = 15,\n  hjust  = 1,\n  margin = margin(r = 2)\n)\n```\n:::\n\n\n\nIn the original plot, the planning-area labels sit far from the bar and the horizontal bar lines extends on the left-hand side of the bars. When labels are far from the bars they describe, readers must track back and forth across the white space, increasing cognitive load. Pulling the text flush to the bar edge establishes an immediate, one-to-one visual link between name and value. Below code chunk aims to achieve that by keeping the layout tight ensuring nothing feels floating in the margin and the plot frame remains compact.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npanel.grid.major.y = element_blank(),\npanel.grid.minor.y = element_blank(),\n```\n:::\n\n\n\n**Putting it Together - Improvement 2**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_totals <- sgdemo2024 %>%\n  group_by(PA) %>%\n  summarise(Pop = sum(Pop, na.rm = TRUE)) %>%\n  filter(Pop > 0) %>%\n  arrange(desc(Pop))\npa_totals$PA <- factor(pa_totals$PA, levels = rev(pa_totals$PA))\n\nggplot(pa_totals, aes(x = PA, y = Pop)) +\n  geom_col(fill = \"steelblue\") +\n  coord_flip(expand = FALSE) +\n  geom_hline(yintercept = 0, linewidth = 0.5, color = \"black\", inherit.aes = FALSE) +\n\n  scale_x_discrete(expand = c(0, 0.02)) +\n\n\n  scale_y_continuous(\n    labels = comma,\n    expand = c(0, 0),\n  ) +\n\n  labs(\n    title = \"Population by Planning Area (Singapore, 2024)\",\n    x     = \"Planning Area\",\n    y     = \"Population\"\n  ) +\n\n  theme_minimal(base_size = 20) +\n  theme(\n\n    axis.text.y = element_text(\n      size   = 15,\n      hjust  = 1,\n      margin = margin(r = 2)\n    ),\n\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n\n    panel.grid.major.x = element_line(color = \"grey80\", linewidth=0.3),\n    panel.grid.minor.x = element_blank(),\n\n    plot.title  = element_text(size = 18, face = \"bold\"),\n    axis.text.x = element_text(size = 10),\n    axis.line.x = element_line(color = \"grey90\", linewidth = 0.8),\n    plot.margin = margin(1, 1, 1, 1, \"pt\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-34-1.png){width=1152}\n:::\n:::\n\n\n\nWow, it already looks much better, cleaner and compact! However, just one more minor tweak to make this even better!\n\n### 4.2.3 Improvement 3 - Binning\n\nThe increment units are 100,000. Let's switch it to 10,000 instead. This allows for finer granularity in mid-range areas as there are some that are clearly a bunch below 100,000. This will also allow for easier side-by-side comparison and better visual balance. Denser grid lines creates a subtler \"graph paper\" effect that can help the eye track horizontally without overwhelming the chart. Hence, I am careful not to make the lines thick. Below code chunk will do exactly that by adding `breaks` and `limits` to our `scale_y_continous`. I have made the limits to `290000 *1.005` to allow for some breathing room as Tampines has more than 280,000 people. The 1.005 will make sure that the font 290 does not get clipped off. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| eval: false \n#| code-fold: false \n\n  scale_y_continuous(\n    limits = c(0, 290000 * 1.005),\n    breaks = seq(0, 290000, by = 10000),\n    expand = c(0, 0),\n    labels = function(x) x / 1000\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<ScaleContinuousPosition>\n Range:  \n Limits:    0 -- 2.91e+05\n```\n\n\n:::\n:::\n\n\n## 4.3 Putting it Together - All Improvements (The Final Horizontal Bar Plot)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(pa_totals, aes(x = PA, y = Pop)) +\n  geom_col(fill = \"steelblue\") +\n\n  # only flip here\n  coord_flip(expand = FALSE) +\n\n  # zero baseline\n  geom_hline(yintercept = 0, linewidth = 0.5, color = \"black\", inherit.aes = FALSE) +\n\n  scale_x_discrete(expand = c(0, 0.02)) +\n\n  # move limits & headroom into the scale\n  scale_y_continuous(\n    limits = c(0, 290000 * 1.005),\n    breaks = seq(0, 290000, by = 10000),\n    expand = c(0, 0),\n    labels = function(x) x / 1000\n  ) +\n\n  labs(\n    title = \"Population by Planning Area (Singapore, 2024)\",\n    x     = \"Planning Area\",\n    y     = \"Population (’000s)\"\n  ) +\n\n  theme_minimal(base_size = 20) +\n  theme(\n    axis.text.y        = element_text(size = 15, hjust = 1, margin = margin(r = 2)),\n    axis.text.x        = element_text(size = 10, margin = margin(t = 5)),\n\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_line(color = \"grey80\", linewidth = 0.3),\n    panel.grid.minor.x = element_blank(),\n    axis.line.x        = element_line(color = \"grey90\", linewidth = 0.8),\n    plot.title         = element_text(size = 18, face = \"bold\"),\n    plot.margin        = margin(t = 5, r = 5, b = 15, l = 5, \"pt\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01p2_files/figure-html/unnamed-chunk-36-1.png){width=1152}\n:::\n:::\n\n\n\n::: callout-important\n## **Conclusion**\nBy ordering the bars from highest to lowest population, removing the horizontal gridlines, tightening the planning-area labels up against their bars, and using 10 000-unit bins (displayed in thousands), this chart maximizes clarity and precision where readers can instantly see which areas are most populous without distracting lines running parallel to the data, directly link each label to its bar without unnecessary white space, and accurately gauge mid-range differences thanks to finer, well-spaced reference ticks. Together, these tweaks sharpen the visual hierarchy, reduce clutter, and make the story behind Singapore’s planning-area populations immediately accessible.\n:::\n\n",
    "supporting": [
      "Take-home_Ex01p2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}