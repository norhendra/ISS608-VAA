{
  "hash": "2eac89af53e54e94c7055a0b0f9c69eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 6\"\nauthor: \"Nor Hendra\"\ndate: \"19 May 2025\"\ndate-modified: \"last-modified\"\nformat: html\neditor: visual\nfreeze: true\nexecute:\n  eval: true\n  echo: true\n  warning: false\ncode-fold: true\n---\n\n\n\n# Visualising and Analysing Time-oriented Data\n\n# 1. Learning Outcome\n\nBy the end of this hands-on exercise you will be able create the followings data visualisation by using R packages:\n\n-   plotting a calender heatmap by using ggplot2 functions,\n\n-   plotting a cycle plot by using ggplot2 function,\n\n-   plotting a slopegraph\n\n-   plotting a horizon chart\n\n# 2. Getting Started\n\n## 2.1 Importing Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n\n## **2.2 Plotting Calendar Heatmap**\n\nIn this section, I will learn how to plot a calender heatmap programmatically by using ggplot2 package.\n\n![](https://r4va.netlify.app/chap17/img/image01.png)\n\nBy the end of this section, you will be able to:\n\n-   plot a calender heatmap by using ggplot2 functions and extension,\n\n-   to write function using R programming,\n\n-   to derive specific date and time related field by using base R and lubridate packages\n\n-   to perform data preparation task by using tidyr and dplyr packages.\n\n## 2.3 The Data\n\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n### 2.3.1 Importing the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n\n### 2.3.2 Examining the data structure\n\nIt is always a good practice to examine the imported data frame before further analysis is performed.\n\nFor example, kable() can be used to review the structure of the imported data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\n\nThere are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in POSIXct format.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n\n### 2.3.3 Data Preparation\n\nStep 1: Deriving weekday and hour of day fields\n\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n\n::: callout-note\n## Note\n\n-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n\n-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.\n:::\n\nStep 2: Deriving the attacks tibble data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n\n::: callout-note\n## Note\n\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they’ll be ordered when plotting\n:::\n\nTable below shows the tidy tibble table after processing\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n\n# 3. Building the Calendar Heatmaps\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Things to learn from the code chunk\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/index.html) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n# 4. Building Multiple Calendar Heatmaps\n\n*Challenge*: Building multiple heatmaps for the top four countries with the highest number of attacks.\n\nStep 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the followings:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attackes by country, and\n\n-   save the results in a tibble data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n\nStep 2: Preparing the tidy data frame\n\nIn this step, you are required to extract the attack records of the top 4 countries from *attacks* data frame and save the data in a new tibble data frame (i.e. *top4_attacks*).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntop4 <- attacks_by_country$source_country[1:4] #<< Top 4 countries \nsummary(top4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n        4 character character \n```\n\n\n:::\n:::\n\n\n\nStep 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n\n## 4.1 Plotting Multiple Calendar Heatmaps\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n\n# 5. Plotting Cycle Plot\n\nIn this section, you will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n## 5.1 Step 1: Data Import\n\nFor the purpose of this hands-on exercise, *arrivals_by_air.xlsx* will be used.\n\nThe code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and save it as a tibble data frame called *air*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n\n## 5.2 Step 2: Deriving month and year fields\n\nNext, two new fields called month and year are derived from Month-Year field.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n\n## 5.3 Step 3: Extracting the target country\n\nNext, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n\n## 5.4 Step 4: Computing year average arrivals by month\n\nThe code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n\n## 5.5 Step 5: Plotting the cycle plot\n::: callout-tip\n## Slight modification to code\nThe X-Axis is all squished up in the original cycle plot, I have made some changes to plot it clearly\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Use existing integer year column\nVietnam$year_num <- Vietnam$year\n\n# Plot\nggplot() + \n  geom_line(data = Vietnam,\n            aes(x = year_num, \n                y = Vietnam, \n                group = month), \n            colour = \"black\") +\n  geom_hline(data = hline.data, \n             aes(yintercept = avgvalue), \n             linetype = 6, \n             colour = \"red\", \n             size = 0.5) + \n  facet_grid(~month) +\n  labs(\n    title = \"Visitor arrivals from Vietnam by air, Jan 2010–Dec 2019\",\n    x = \"\",\n    y = \"No. of Visitors\"\n  ) +\n  theme_tufte(base_family = \"Helvetica\") +\n  theme(\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n\n# 6. Plotting Slopegraph\n\nIn this section I will learn how to plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\nBefore getting start, make sure that **CGPfunctions** has been installed and loaded onto R environment. Then, refer to [Using newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to learn more about the function. Lastly, read more about `newggslopegraph()` and its arguments by referring to this [link](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph).\n\n## 6.1 Step 1: Data Import\n\nImport the rice data set into R environment by using the code chunk below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n\n## 6.2 Step 2: Plotting the slopegraph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Nor Hendra\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Thing to learn from the code chunk above\n\nFor effective data visualisation design, `factor()` is used convert the value type of *Year* field from numeric to factor.\n:::\n\n# 6.3 Extras\n\n### 6.3.1 Stream Graph\n\n#### 6.3.1.1 Loading Packages\n\nggstream will be used to plot the Stream Graph (aka Theme River). Although other packages are already loaded, I have included them in this pacman load to show what I will be using for this plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(ggstream,dplyr,tidyr,ggplot2,scales)\n```\n:::\n\n\n\n#### 6.3.1.2 Plotting the Stream Graph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice_stream <- rice %>%\n  filter(Year >= 1961, Year <= 1980) %>%\n  group_by(Year, Country) %>%\n  summarise(Yield = sum(Yield, na.rm = TRUE), .groups = \"drop\")\n\n\ntop_countries <- rice_stream %>%\n  group_by(Country) %>%\n  summarise(total = sum(Yield)) %>%\n  arrange(desc(total)) %>%\n  slice(1:11) %>%\n  pull(Country)\n\nrice_stream <- rice_stream %>% filter(Country %in% top_countries)\n\n\n\nggplot(rice_stream, aes(x = Year, y = Yield, fill = Country)) +\n  geom_stream(type = \"ridge\") +\n  scale_y_continuous(labels = label_comma()) + \n  labs(\n    title = \"Rice Yield of Top 11 Asian Countries (1961–1980)\",\n    x = \"Year\", y = \"Yield (tonnes/ha)\",  \n    caption = \"Static streamgraph using ggstream\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n### 6.3.2 Animated Bubble Plot\n\nWe have done this hands-on before, but let's see what this rice data looks like on an animated bubble plot.\n\n::: callout-note\n## nframes adjustment\n\nI first tried `animate(p, nframes = 40, fps = 10, width = 600, height = 450)` which looked much better but it seems like it took too long to render and was not saving. Hence, I changed it to nframes = 30 and used `renderer = gifski_renderer` to not preview. Afterwards, it was working fine. The 2 animation plots will be using this set up.\n:::\n\n#### 6.3.2.1 Loading Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(gganimate,ggplot2,dplyr,scales)\n```\n:::\n\n\n\n#### 6.3.2.2 The Plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbubble_data <- rice %>%\n  filter(Year >= 1961, Year <= 1980) %>%\n  group_by(Year, Country) %>%\n  summarise(Yield = mean(Yield, na.rm = TRUE), .groups = \"drop\") %>%\n  filter(!is.na(Yield))\n\n\nbubble_data$Size <- 1  \n\np <- ggplot(bubble_data, aes(x = Year, y = Yield, size = Size, color = Country)) +\n  geom_point(alpha = 0.7) +\n  scale_size(range = c(2, 12), guide = \"none\") +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = 'Rice Yield by Country: {closest_state}',\n    x = 'Year', y = 'Yield (tonnes/ha)'\n  ) +\n  theme_minimal() +\n  transition_states(Year, transition_length = 2, state_length = 1) +\n  ease_aes('linear')\n\n\nanimate(p, nframes = 30, renderer = gifski_renderer(\"rice_yield_bubble.gif\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-22-1.gif)\n:::\n:::\n\n\n\n::: callout-tip\n## Observation\n\nI don't think this is useful, but from the animation - a line animation would be much better! So let's try that.\n:::\n\n### 6.3.3 Animating Line Graph Method\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare the data\nline_data <- rice %>%\n  filter(Year >= 1961, Year <= 1980) %>%\n  group_by(Year, Country) %>%\n  summarise(Yield = mean(Yield, na.rm = TRUE), .groups = \"drop\") %>%\n  filter(!is.na(Yield))\n\n# Optional: Keep only top 11 countries by total average yield over the years\ntop_countries <- line_data %>%\n  group_by(Country) %>%\n  summarise(total_yield = sum(Yield, na.rm = TRUE)) %>%\n  slice_max(order_by = total_yield, n = 11) %>%\n  pull(Country)\n\nline_data <- line_data %>% filter(Country %in% top_countries)\n\n# Plot\np <- ggplot(line_data, aes(x = Year, y = Yield, color = Country, group = Country)) +\n  geom_line(linewidth = 1.2) +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = \"Rice Yield by Country (1961–1980)\",\n    subtitle = \"Year: 1960 to 1980\",\n    x = \"Year\", y = \"Yield (tonnes per hectare)\",\n    caption = \"Animated line plot using gganimate\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  transition_reveal(Year)\n\n# Animate\nanimate(p, nframes = 30, renderer = gifski_renderer(\"rice_yield.gif\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-23-1.gif)\n:::\n:::\n\n\n\n### 6.3.4 Time on the Horizon: ggHoriPlot methods\n\nA horizon graph is an analytical graphical method specially designed for visualising large numbers of time-series. It aims to overcome the issue of visualising highly overlapping time-series as shown in the figure below.\n\nA horizon graph essentially an area chart that has been split into slices and the slices then layered on top of one another with the areas representing the highest (absolute) values on top. Each slice has a greater intensity of colour based on the absolute value it represents.\n\n#### 6.3.4.1 Data Import\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverp <- read_csv(\"data/AVERP.csv\") %>%\n  mutate(`Date` = dmy(`Date`))\n```\n:::\n\n\n\n::: callout-tip\n## Things to learn from the code chunk above\n\n-   By default, read_csv will import data in Date field as Character data type. [`dmy()`](https://lubridate.tidyverse.org/reference/ymd.html) of [**lubridate**](https://lubridate.tidyverse.org/) package to palse the Date field into appropriate Date data type in R.\n:::\n\n#### 6.3.4.2 Plotting the horizon graph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverp %>% \n  filter(Date >= \"2018-01-01\") %>%\n  ggplot() +\n  geom_horizon(aes(x = Date, y=Values), \n               origin = \"midpoint\", \n               horizonscale = 6)+\n  facet_grid(`Consumer Items`~.) +\n    theme_few() +\n  scale_fill_hcl(palette = 'RdBu') +\n  theme(panel.spacing.y=unit(0, \"lines\"), strip.text.y = element_text(\n    size = 5, angle = 0, hjust = 0),\n    legend.position = 'none',\n    axis.text.y = element_blank(),\n    axis.text.x = element_text(size=7),\n    axis.title.y = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.border = element_blank()\n    ) +\n    scale_x_date(expand=c(0,0), date_breaks = \"3 month\", date_labels = \"%b%y\") +\n  ggtitle('Average Retail Prices of Selected Consumer Items (Jan 2018 to Dec 2022)')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n## 6.3.5 BumpCharts in R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(2005, 2006, 2007, 2008, 2009, 2010)) %>%\n  ggplot(aes(x = Year,\n         y = Yield,\n         color = Country))+\n  geom_point(color = \"#FFFFFF\", size = 1) +\n  ggbump::geom_bump(mapping=aes(x = Year,\n                                y = Yield, \n                                group = Country\n                                ))+\n  labs(title = \"Rice Yield of Top 11 Asian Countries\") +  \n  theme_minimal()+\n  theme(\n        plot.background = element_rect(fill = \"#f5f5f5\", color = \"#f5f2f5\"),\n        panel.background = element_rect(fill=\"#f5f5f5\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n## 6.3.6 LineColour\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(2005, 2006, 2007, 2008, 2009, 2010)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Countries\",\n                SubTitle = \"2005 to 2010\",\n                Caption = NULL,\n                LineColor = c(\"Korea\" = \"#e0218a\", \"Thailand\" = \"#FFBC2F\"),\n                DataLabelFillColor = \"#f5f5f5\",) +\n    theme(\n        plot.background = element_rect(fill = \"#f5f5f5\", color = \"#f5f2f5\"),\n        panel.background = element_rect(fill=\"#f5f5f5\")\n      ) \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}